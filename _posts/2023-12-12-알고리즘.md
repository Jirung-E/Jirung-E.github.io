---
title: "알고리즘"
excerpt: "알고리즘 기말고사 대비 정리"
last_modified_at: 2023-12-12T15:28:04

categories: 
  - Algorithm

tags: 
  - greedy
  - dynamicprogramming

toc: true
toc_sticky: true
---


  
## Greedy  
한번 내린 결정을 번복하지 않는다.  
단순하고 제한적인 문제에서만 정확한 해를 찾게 해준다.  
  
### 동전 거스름돈 문제  
각 동전들이 정수배 관계에 있을 때만 적용 가능하다.  
  
### 최소 신장 트리  
가중치 그래프에서 사이클이 없이 모든 정점을 연결하는 부분 그래프     
점의 수가 n개인 그래프의 최소 신장 트리는 n-1개의 간선을 가진다.  
  
#### Kruskal  
간선을 가중치의 오름차순으로 정렬한 후, 사이클을 이루지 않는 가장 짧은 간선을 선택한다.     
n-1개의 간선을 선택할 때까지 반복한다.     
알고리즘 진행중에 여러개의 트리가 생길 수 있는데, 최종적으로는 하나로 합쳐진다.  
- 시간복잡도: 정렬을 하기 때문에 O(ElogE)  
  
#### Prim  
임의의 정점을 시작점으로 하여, 시작점과 연결된 간선들 중 가장 짧은 간선을 선택한다.     
트리 안에 있는 점에서 트리 밖에 있는 점으로 연결하므로 사이클이 생기지 않는다.     
- 시간복잡도: 루프 n-1회 * 최소인 간선을 찾는데 O(log n) = O(n * log n)  
  + 간선수가 m일때 최소힙을 사용해서 찾으면 O(m * log n)이 된다.  
  
### 최단 경로  
주어진 가중치 그래프에서 어느 한 출발점에서 또 다른 도착점까지의 최단 경로를 찾는 문제  
  
#### Dijkstra  
시작점에서부터 각 정점까지의 최단 거리를 구하는 알고리즘      
출발점으로부터 최단 거리가 확정되지 않은 점들 중에서 출발점으로부터 가장 가까운 점을 추가하고, 그 점의 최단 거리를 확정.     
- 시간복잡도: O(n^2)  
  + 최소힙을 사용하면 O(n * log n), 간선수가 m일때 O(m * log n)  
  
  
### 부분 배낭 문제  
무게 제한이 있는 배낭에 물건을 넣을 때, 가치의 합이 최대가 되도록 하는 문제     
물건을 쪼개서 넣을 수 있어서 greedy 알고리즘을 적용할 수 있다.     
무게당 가치가 높은 물건부터 넣는다.     
- 시간복잡도: 가치에 따라 정렬을 해야하므로 O(nlogn)  
  
### 집합 커버 문제  
부분집합들을 가장 적게 더해서 전체집합을 만드는 문제     
greedy 알고리즘으로 근사해를 구할 수 있다.     
커버하는 원소가 많은 부분집합부터 선택한다.  
- 시간복잡도: O(n^3)  
  
### 작업 스케줄링 문제  
기계와 작업이 주어질 때, 모든 작업을 가장 빨리 끝내는 방법을 찾는 문제     
greedy 알고리즘으로 근사해를 구할 수 있다. `빠른 시작시간 작업 우선 배정`, `빠른 종료시간 작업 우선 배정`, `짧은 작업 우선 배정`, `긴 작업 우선 배정` 등의 방법이 있는데, 1번 방법을 제외한 나머지는 최적해를 보장하지 못한다.     
- 시간복잡도: 작업을 정렬하는데 O(nlogn), 수행가능한 기계를 찾는데 O(m * n)(m: 기계수, n: 작업수), 따라서 O(n * log n) + O(m * n)  
  
### 허프만 압축  
문자열 압축 알고리즘.     
문자열의 빈도수를 이용하여 가장 빈번한 문자에 가장 짧은 코드를 부여하는 방식으로 압축한다.     
빈도수에 기반을 둔 이진 트리를 만들어서, 각 문자에 이진 코드를 할당한다.     
힙을 사용해서 빈도수가 작은 것부터 2개씩 뽑아서 트리를 만든다.     
별도의 separator를 사용하지 않아도 되도록 코드를 부여한다.     
> 10110010001110101010100 -> 101 100 100 0 11 101 0 101 0 100     
- 시간복잡도: O(n * log n) (힙)  
  
- - -  
  
## Dynamic Programming  
입력 크기가 작은 부분 문제들을 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘  
  
### 모든 쌍 최단 경로 문제  
#### Floyd-Warshall  
모든 정점에서 모든 정점으로의 최단 경로를 구하는 알고리즘     
작은 문제: 정점 a, b, c가 있을때 a->c로 가는 지금까지 알려진 비용과 a->b->c로 가는 비용을 비교해서 더 작은 비용을 저장     
Dijk: { 1, 2, 3, ..., k }를 거쳐갈때 i에서 j로 가는 최단경로  
```rs  
for k in 1..n {  
    for i in 1..n (i != k) {  
        for j in 1..n (j != k, j != i) {  
            Dijk = min(Dijk, Dik + Dkj)  
        }  
    }  
}  
```  
k를 경유하는 거리를 얻기 위해 k-1을 경유하는 거리를 다 구한다.  
- 시간복잡도: O(n^3)  
  
### 연쇄 행렬 곱셈 문제  
가장 효율적인 순서로 행렬을 곱하는 문제  
- 시간복잡도: 부분문제의 크기를 늘리는 루프 * 부분문제의 개수를 늘리는 루프 * 부분문제를 푸는 루프 = O(n^3)  
  
### 0-1 배낭 문제  
물건을 나눌 수 없는 배낭 문제     
다이나믹 프로그래밍, 백트래킹, 분기 한정법 등으로 풀 수 있다.  
- 시간복잡도: O(n * W) (n: 물건의 수, W: 배낭의 용량)  
  
### 동전 거스름돈 문제  
각 동전들이 정수배 관계가 아닐때 다이나믹 프로그래밍으로 풀 수 있다.     
동전들을 정렬한 후, 각 동전을 사용할지 말지를 결정한다.     
잔돈의 액수 만큼의 길이를 가지는 배열을 만들고 각 인덱스에 해당하는 금액을 만들기 위한 최소 동전의 개수를 저장한다.(만들 수 없다면 -1을 저장한다.)     
만들 수 있는 금액이라면, 그 금액에서 동전의 가치를 뺀 금액을 만들기 위한 최소 동전의 개수에 1을 더한 값을 저장한다.     
- 시간복잡도: O(n * k) (n: 동전의 수, k: 거스름돈)  
  
- - -  
  
## NP-Complete  
### P문제  
다항 시간 내에 풀 수 있는 문제  
  
### NP문제  
다항 시간 내에 답을 검산할 수 있는 문제  
  
### NP-Hard  
NP문제보다 어려운 문제     
NP에 속하는 모든 판정문제를 다항 시간 내에 다대일 환산할 수 있는 문제  
  
### NP-Complete  
NP문제 중에서 가장 어려운 문제     
NP문제이면서 NP-Hard인 문제     
NP-Complete 문제를 다항 시간 내에 풀 수 있다면, 모든 NP문제를 다항 시간 내에 풀 수 있다.     
모든 NP문제를 다항 시간 내에 NP-Complete 문제로 환산할 수 있다.  
  
- - -  
  
## 근사 알고리즘  
np완전문제를 풀기 위해 다음의 3가지 중에서 1가지는 포기해야 한다.  
1. 정확한 해를 구하는 것  
2. 다항 시간 내에 해를 구하는 것  
3. 모든 입력에 대해 해를 구하는 것     
  
근사 알고리즘은 1번을 포기하고 2번과 3번을 만족하는 알고리즘이다.     
근사해를 찾는 대신에 다항식 시간의 복잡도를 가진다.     
근사비율을 함께 제시해야한다.     
1.0에 가까울수록 정확도가 높다.    
근사비율을 계산하려면 최적해를 알아야 하는데, 이를 위한 간접적인 최적해를 찾는다.    
다항식 시간복잡도로 풀 수 있는데 정답은 아니다.  
  
#### 여행자 문제  
##### MST 이용  
MST간선의 합을 M이라고 하면, 최적해는 M보다 반드시 크다.     
  
가정:     
1. 근사해는 2M보다 작다.    
2. 직접 가는 경로가 들렀다 가는 경로보다 짧다.  
3. 모든 도시는 연결되어 있다.    
- 근사비율: 2.0  
  
#### 정점커버 문제  
##### 집합 커버 이용  
- 근사비율: k * ln n  
  
##### Maximal Matching 이용  
간선의 양 끝점이 이미 커버된 간선의 끝점이 아닐 때에만 선택  
- 근사비율: 2.0  
  
#### 통 채우기 문제  
##### Greedy 이용  
1. 최초 적합(First Fit)  
2. 다음 적합(Next Fit)  
3. 최선 적합(Best Fit)  
4. 최악 적합(Worst Fit)  
- 근사비율: 2.0  
  
#### 작업 스케줄링 문제  
- 근사비율: 2.0  
  
#### 클러스터링  
##### greedy 이용  
- 근사비율: 2.0  
  
#### 부분집합의 합 문제  
각 원소를 더했을 때 특정값이 되는 경우를 찾는 문제  
파티션 문제를 이용해서 근사해를 구할 수 있다.  
##### 파티션 문제  
주어진 집합을 두 개의 부분집합으로 나누었을 때, 두 부분집합의 합이 같도록 하는 문제  
```rs  
set = [ 20, 45, 35, 70, 80 ]  
K = 105  
sum = sumof(set)   // 250  
  
// sum-K = 145  
// K+40 = 145  
// set에 40을 추가하면 partition 문제로 해결할 수 있다.  
```  
- 근사비율: 2.0  

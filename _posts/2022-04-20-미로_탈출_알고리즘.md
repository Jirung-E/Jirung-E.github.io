---
title: "미로 탈출 알고리즘"
excerpt: "Recursive Back Tracking을 이용해서 미로를 탈출해 봅시다"
last_modified_at: 2022-04-20T22:40:00

categories:
  - Algorithm

tags:
  - 재귀
  - 미로
  - 길찾기
  - C++

toc: true
toc_sticky: true
---

## Recursive Back Tracking Algorithm
이름에서 알 수 있듯이 재귀호출을 이용한 알고리즘 입니다.  
단점은, 미로가 전체적으로 어떻게 생겼는지 알고 있어야 한다는 것입니다.  

## 코드
코드가 좀 긴데... 리펙터링을 안했다.. 미안하다.. ㅎㅎ;; ㅈㅅ.. ㅋㅋ!!  
사실 보라고 만든 포스트가 아니라 테스트용 포스트지롱 ㅋㅋ!!  
```cpp
void recursive_backtracking() {
    using namespace std;

    bool** visited = new bool*[height];
    for(int i=0; i<height; ++i) {
        visited[i] = new bool[width];
    }
    for(int i=0; i<height; ++i) {
        for(int k=0; k<width;++k) {
            if(isBlock(map[i][k])) {
                visited[i][k] = true;
            }
        }
    }
    stack<Player_::Position> stk;

    bool repeat = true;
    while(repeat) {
        // 방문했다고 체크
        if(visited[player.position.y][player.position.x] == false) {
            //cout << "visit check" << endl;
            visited[player.position.y][player.position.x] = true;
            stk.push(player.position);
        }

        // 갇혔는지
        bool istrapped[4] = { false, false, false, false };

        // 왼쪽 ㄱㄴ?
        if(player.position.x > 0) {
            if(visited[player.position.y][player.position.x-1]) {
                istrapped[0] = true;
            }
            else {
                istrapped[0] = false;
            }
        }
        else {
            istrapped[0] = true;
        }
        // 오른쪽 ㄱㄴ?
        if(player.position.x < width-1) {
            if(visited[player.position.y][player.position.x+1]) {
                istrapped[1] = true;
            }
            else {
                istrapped[1] = false;
            }
        }
        else {
            istrapped[1] = true;
        }
        // 위 ㄱㄴ?
        if(player.position.y > 0) {
            if(visited[player.position.y-1][player.position.x]) {
                istrapped[2] = true;
            }
            else {
                istrapped[2] = false;
            }
        }
        else {
            istrapped[2] = true;
        }
        // 아래 ㄱㄴ?
        if(player.position.y < height-1) {
            if(visited[player.position.y+1][player.position.x]) {
                istrapped[3] = true;
            }
            else {
                istrapped[3] = false;
            }
        }
        else {
            istrapped[3] = true;
        }

        // 갇힘
        if(istrapped[0]) {
            if(istrapped[1]) {
                if(istrapped[2]) {
                    if(istrapped[3]) {
                        // 이전셀로 이동
                        if(stk.empty()) {
                            repeat = false;
                            std::cout << "failed.." << std::endl;
                            break;
                        }
                        //std::cout << "back" << std::endl;
                        map[player.position.y][player.position.x] = new Object { '.' };
                        player.position = stk.top();
                        stk.pop();
                        continue;
                    }
                }
            }
        }


        // 랜덤한 방향으로 이동
        switch(randomDirection()) {
            case Player_::Direction::Up:
                player.direc = Player_::Direction::Up;
                break;
            case Player_::Direction::Right:
                player.direc = Player_::Direction::Right;
                break;
            case Player_::Direction::Down:
                player.direc = Player_::Direction::Down;
                break;
            case Player_::Direction::Left:
                player.direc = Player_::Direction::Left;
                break;
        }

        if(Next() == ObjectCode::Goal) {
            Show();
            cout << "Clear!" << endl;
            repeat = false;
            break;
        }

        switch(player.direc) {
            case Player_::Direction::Down:
                if(visited[player.position.y+1][player.position.x] == false) {
                    GoAhead();
                }
                break;
            case Player_::Direction::Up:
                if(visited[player.position.y-1][player.position.x] == false) {
                    GoAhead();
                }
                break;
            case Player_::Direction::Left:
                if(visited[player.position.y][player.position.x-1] == false) {
                    GoAhead();
                }
                break;
            case Player_::Direction::Right:
                if(visited[player.position.y][player.position.x+1] == false) {
                    GoAhead();
                }
                break;
        }
    }

    for(int i=0; i<height; ++i) {
        delete[] visited[i];
    }
    delete[] visited;
}
```

## 미로
![미로](/images/maze.png)
